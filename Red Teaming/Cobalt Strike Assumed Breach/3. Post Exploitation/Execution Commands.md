The `shell` and `run` commands allow operators to run any arbitrary command on the target and get the output.

> Generally speaking, executing commands and programs in this way is considered bad OPSEC.  Beacon provides many API-only commands that aim to replace the need to run these types of commands.  For instance, use `ls` over dir and `getuid` over whoami.
## shell

The `shell` command can be used to execute commands as though you would through a normal command prompt.

```powershell
beacon> help shell
Use: shell [command] [arguments]

Execute the command using cmd.exe
```

It passes the provided command and arguments through `cmd.exe /c`, so `shell whoami /user` would get executed on the target as `cmd.exe /c whoami /user`.

```powershell
beacon> shell whoami /user

USER INFORMATION
----------------

User Name   SID                                         
=========== ============================================
dev\bfarmer S-1-5-21-569305411-121244042-2357301523-1104
```

## run

The `run` command does not use cmd.exe, but rather executes the target program directly.

```powershell
beacon> help run
Use: run [program] [arguments]

Execute the program. Returns output.

beacon> run whoami /user

USER INFORMATION
----------------

User Name   SID                                         
=========== ============================================
dev\bfarmer S-1-5-21-569305411-121244042-2357301523-1104
```

Both return the same output, but they work in different ways.  You may choose one or the other based on these behavioural differences or when trying to emulate a specific threat actor.  Some commands such as **dir** will only work with `shell`, because dir is only a command that exists in cmd.exe and not a separate program that exists on disk.  **whoami** is a separate program that exists inside the System32 directory, which is why it works with both `shell` and `run`.
