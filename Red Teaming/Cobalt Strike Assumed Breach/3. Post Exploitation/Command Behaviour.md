Each Beacon command can be categorised according to how it operates under the hood. Some commands only use Windows APIs, some execute code inside the Beacon process, and some will inject into remote processes.  It's important for an operator to know how each command behaves so they can assess any that may be unsafe to run in the presence of a known defence.

### House-Keeping

These commands exist to configure Beacon by changing a setting at runtime.  These commands include `sleep`, `spawnto`, `jobs`, and `ppid`.  They generally don't execute anything, but simply change or return values stored within Beacon's memory.

### API-Only

These are built into Beacon and are the most benign of commands that actually perform an action.  Commands that only call Win APIs include `cd`, `cp`, `ls`, `mv`, `ps`, `pwd`, `rm`, and `upload`.

### Inline Execution

There is a command built into Beacon called `inline-execute` which expects to receive a Beacon Object File (BOF) in the job data passed down from the team server.  A BOF is a C program that is compiled without a linker - Beacon will parse the BOF and act as the linker and loader to execute the content.  One advantage of BOFs is that they run inside the memory space of Beacon, which provides an alternative to fork & run (discussed next).  The disadvantage being that if the code inside the BOF crashes, then the Beacon will die along with it.

Some Beacon commands such as `dllload`, `getsystem`, and `timestomp` are implemented as BOFs.  Operators can also write their own BOFs to being additional functionality to Beacon.  A BOF may operate like an API-only command (in that it may only use native APIs), but there is additional work that Beacon must do to load and execute a BOF.

### Fork & Run

'Fork & run' is used to describe an execution pattern where a temporary process is spawned and a post-ex capability (written as a reflective DLL) is injected into it.  The output of the capability is then typically read over a named pipe.  This pattern provides better stability for Beacon at the expense of a larger detection surface.  Fork and run in Cobalt Strike has two flavours, called 'spawn' and 'explicit'.  The 'spawn' variant will execute the post-ex capability as just described; whereas the 'explicit' variant injects the post-ex capability into a process that already exists.

Some commands can only run as the 'spawn' variant, such as `execute-assembly` and `powerpick`; some can only run as the 'explicit' variant, such as `psinject`; and others, such as `mimikatz`, `portscan`, and `keylogger`, can run as either variant.  You can tell which command support which variant by looking at its help text.  If the command syntax accepts `[arch]` and `[pid]` arguments, then it's 'explicit', otherwise it's 'spawn'.

```powershell
beacon> help execute-assembly
Use: execute-assembly [/path/to/file.exe] [arguments]  << spawn

beacon> help psinject
Use: psinject [pid] [arch] [commandlet] [arguments]    << explicit

beacon> help mimikatz
Use: mimikatz [pid] [arch] [module::command] <args>    << explicit
     mimikatz [module::command] <args>                 << spawn
```

The 'explicit' variant also comes in useful when you want to inject a post-ex capability into a process owned by other user.  For example, running `keylogger [pid] [x86|x64]` against a process owned by another user will log their keystrokes (assuming your Beacon has sufficient privileges to perform the injection).