A _program_ is a set of instructions that have been compiled into a PE file, typically a `.exe` or `.dll`.  A _process_ can be thought of as a container to hold the resources of a running program.  Multiple instances of the same program can be run, but they will do so in separate processes, and therefore have their own set of resources that are (mostly) isolated from each other.

There are multiple APIs that can be used to start a process depending on your requirements.  The simplest is [CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) which creates a process that will have the same access token as the caller; [CreateProcessAsUserW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw) can create a process using an alternate access token; and [CreateProcessWithLogonW](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw) can create a process using a user's plaintext credentials.  Ultimately, each API calls into the NtCreateUserProcess kernel function.
![[Pasted image 20250626104838.png]]

## Threads

A thread is a type of object that Windows schedules for execution within a process.  It holds the state of the CPU, including its registers; and a call stack, which is the set of CPU instructions to execute.  Every functional program will have at least one thread that is used to execute the program's entry point, however, many applications run multiple threads to allow multiple pieces of work to execute in parallel.

The simplest thread creation functions are [CreateThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), which creates a new thread in the calling process; and [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread), which can create a new thread in another process.  The most important argument is the function pointer as this acts as the new thread's entry point for execution.  Both of these APIs call into [CreateRemoteThreadEx](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex), which then calls the NtCreateRemoteThreadEx kernel function.

## Memory

Every process has its own private virtual memory that it uses to store data during its runtime.  The Windows memory manager transparently maps a process's virtual memory to physical memory, and may even page data to disk when needed.

![[Pasted image 20250626105642.png]]

Memory management is performed on distinct chunks, called _pages_, of which there are two supported sizes:  small and large.  A small page is 4KB on x86, x64, and ARM CPUs; and a large page is 2MB on x86 and x64, and 4MB on ARM.  Windows provides multiple APIs that can be used to allocate and free virtual memory in a process, of which there are three main families:

- #### Virtual APIs
    
    These are the lower-level APIs that are used for general (de)allocations and include functions such as [VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [VirtualFree](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree), and [VirtualProtect](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect).  Even though these accept a 'size' argument, the value is always rounded up to the nearest complete page.
    
- #### Heap APIs
    
    These APIs include [HeapAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc), [HeapReAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heaprealloc), and [HeapFree](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree), and are used to manage memory allocations that are smaller than a page.  The heap manager can be thought of an abstraction over the aforementioned virtual APIs.  It allocates pages of memory but optimises its usage by managing smaller allocations within those pages.
    
- #### Memory-mapping APIs
    
    These APIs are designed to map files into memory from disk, and even share those mappings across processes.  These include [CreateFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga), [OpenFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfilemappinga), and [MapViewOfFile](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile).

## Access Tokens

When a process is spawned, it is assigned with a primary access token that describes the _security context_ of the user that started it.  This information includes the user's SID, their group SIDs, and their privileges (described below).  When a process performs an action on the system, it occurs under the context of the user.

By default, new threads do not have a specific access token assigned to them, and therefore inherit the security context of the process's primary access token.  However, a thread can also impersonate the access token of another user and any work that thread performs will be under the security context of that impersonated user.

![[Pasted image 20250626110249.png]]

Every securable object (files, processes, threads, etc) in Windows has a discretionary access control list (DACL), which specifies who has what access to the object.  When a caller attempts to perform an action against an object, an access check is performed against the object's DACL and the information contained in the caller's access token.  Access is granted if the checks pass, otherwise access is denied.

## Privileges

A _privilege_ grants a security principal with the right to perform a system-related operation, such as changing the time zone (requires SeTimeZonePrivilege) or shutting down the computer (requires SeShutdownPrivilege).  These [privileges](https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) are granted by the system administrators, typically via GPOs or locally with [secpol](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/how-to-configure-security-policy-settings).

Before a process can perform the desired operation, it must first enable the corresponding privilege within its access token using [AdjustTokenPrivileges](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges).  If the privilege has not been granted to them, the call will fail.  When the process attempts to perform the operation, the callee uses [LsaEnumerateAccountRights](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-lsaenumerateaccountrights) to verify that the required privilege is enabled in the callers token.

There are privileges that are so powerful that any user that can enable them can effectively take control of the entire computer, even if they are not administrators.  These include:

- **SeDebugPrivilege** - obtain read/write handles to any process, even those owned by other users or SYSTEM.
- **SeTakeOwnershipPrivilege** - take ownership of any securable object including files, handles, and threads.
- **SeRestorePrivilege** - replace any file on the system. 
- **SeLoadDriverPrivilege** - load a device driver into the kernel.
- **SeCreateTokenPrivilege** - create arbitrary access tokens to impersonate any user with any privilege and any domain group membership.

## Termination

A process may terminate itself gracefully by calling [ExitProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess).  This is generally linked into every executable by the compiler and called when the program's primary thread returns from the main function.  However, a programmer may also call it explicitly if they wish.  When a process is terminated 'gracefully', it means that other modules loaded into the process (e.g. DLLs) are given a chance to do some work before the process's resources are disposed of.  ExitProcess can only be used by a program to terminate itself.

A process may terminate another process by calling [TerminateProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess).  However, this forces an 'ungraceful' termination, which means all the process's threads are terminated abruptly and loaded modules are not given a chance to do any work before hand.  Therefore, this can result in data loss or corruption, depending on what the process is doing when terminated.