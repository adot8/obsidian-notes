
Code snippet
```c
/*

 Red Team Operator course code template
 storing payload in .text section
 
 author: reenz0h (twitter: @sektor7net)

*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// 4 byte payload
	unsigned char payload[] = {
		0x90,		// NOP
		0x90,		// NOP
		0xcc,		// INT3
		0xc3		// RET
	};
	unsigned int payload_len = 4;
	
	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);
	
	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```


---

#### Breakdown

##### Initialized Local Variables and .text Section

**_Initialized local variable_** is a variable that is declared within a function or a block of code and is assigned a value at the point of declaration. In programming languages like C and C++, local variables can be initialized like this:

```c
int main() {
    int l_LocalVariable = 42; // Initialized local variable

    printf("The value of the local variable is: %d\n", l_LocalVariable);
    return 0;
}
```

During a compilation time the compiler will take the initialized values and put them directly in the code section (`.text`), because local variables are stored on the stack, and assigned values have to be passed to these variables at runtime before being used later in the code.

###### Shellcode execution algorithm (C-like pseudo-code)

```c
// 1. allocate memory buffer in local process as Read/Write region to store shellcode 
exec_mem = VirtualAlloc(..., payload_length,..., PAGE_READWRITE)

// 2. copy shellcode into allocated memory buffer
RtlMoveMemory(exec_mem, payload, payload_length)

// 3. make the allocated buffer to be executable
VirtualProtect(exec_mem, payload_length, PAGE_EXECUTE_READ,...)

// 4. execute shellcode in local process by creating a new thread
CreateThread(..., exec_mem, ...)
```


###### Intel CPU Instructions

`NOP`

In x86 and x64 Intel CPU architectures, the **_NOP (No Operation)_** instruction is used to perform no operation or simply to introduce a delay in the program execution. It does not affect any of the CPU's flags or modify any registers.

The `NOP` instruction is represented by the opcode `0x90`.

---

`INT3`

**_INT3_** instruction is a **_software interrupt instruction_** that generates a breakpoint exception. It is used as a debugging aid and is often inserted into code intentionally to allow developers to pause the execution of a program at a specific location and inspect its state using a debugger.

The opcode for the `INT3` instruction is `0xCC`.

---

`RET`

**_RET (Return)_** instruction is used to return control from a subroutine to the calling function. It pops the return address from the top of the stack and transfers program execution to that address, effectively returning control to the caller.

The opcode for the `RET` instruction is `0xC3`.

---
#### Key Windows API functions

[**_VirtualAlloc()_**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function is used for reserving and committing memory in the virtual address space of a process. It allows a program to dynamically allocate memory during runtime, providing more flexibility and control over memory management. This function can be found in the _kernel32.dll_ library.

`VirtualAlloc()` function has the following prototype:

```c
LPVOID VirtualAlloc(
  LPVOID lpAddress,        // starting address of the region to allocate. If NULL, the system determines where to allocate the region
  SIZE_T dwSize,           // size of the region to allocate (in bytes)
  DWORD  flAllocationType, // type of memory allocation. Typically: MEM_COMMIT, MEM_RESERVE
  DWORD  flProtect         // memory protection for the region of pages to be allocated, ex. PAGE_READWRITE, PAGE_EXECUTE_READWRITE, etc.
);
```

**Return value**
If the function succeeds, the return value is the base address of the allocated region of pages. Otherwise, the return value is `NULL`.

---

[**_RtlMoveMemory()_**](https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory) function is used for memory block copy operations and is similar to the standard `memcpy` function. This function can be found in the _ntdll.dll_ library.

`RtlMoveMemory()` function has the following prototype:

```c
void RtlMoveMemory(
  void *Destination,    // pointer to the destination memory block to copy the bytes to
  const void *Source,   // pointer to the source memory block to copy the bytes from
  size_t Length         // number of bytes to copy from the source to the destination
);
```

**Return value**
None.

---

[**_VirtualProtect()_**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) function is used to change the protection attributes of a region of virtual memory in the address space of a process. This allows you to control the access rights and permissions for a particular memory region, such as making it readable, writable, executable, or a combination of these attributes. This function can be found in the _kernel32.dll_ library.

`VirtualProtect()` function has the following prototype:

```c
BOOL VirtualProtect(
  LPVOID lpAddress,      // address of the starting page of the region of pages whose access protection attributes are to be changed
  SIZE_T dwSize,         // size of the region whose access protection attributes are to be changed (in bytes)
  DWORD  flNewProtect,   // memory protection option, ex. PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE, PAGE_READWRITE, etc.
  PDWORD lpflOldProtect  // pointer to a variable that receives the previous access protection value. If NULL, the function fails
);
```

>  More on `PDWORD lpflOldProtect`; this is used to store previous page protection bits so the program can (if desired) restore them later. 
> 
> The function expects a pointer (`PDWORD`) for that parameter; using `&oldprotect` passes the address of your `DWORD` variable so the kernel can write the old protection value there.

> Don’t reuse the same variable for the restore call unless you handle it carefully

**Return value**
If the function succeeds, the return value is nonzero. Otherwise, the return value is zero.

