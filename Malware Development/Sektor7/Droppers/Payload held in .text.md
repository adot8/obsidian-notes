
Code snippet
```c
/*

 Red Team Operator course code template
 storing payload in .text section
 
 author: reenz0h (twitter: @sektor7net)

*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// 4 byte payload
	unsigned char payload[] = {
		0x90,		// NOP
		0x90,		// NOP
		0xcc,		// INT3
		0xc3		// RET
	};
	unsigned int payload_len = 4;
	
	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);
	
	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```


---

#### Breakdown

##### Initialized Local Variables and .text Section

**_Initialized local variable_** is a variable that is declared within a function or a block of code and is assigned a value at the point of declaration. In programming languages like C and C++, local variables can be initialized like this:

```c
int main() {
    int l_LocalVariable = 42; // Initialized local variable

    printf("The value of the local variable is: %d\n", l_LocalVariable);
    return 0;
}
```

During a compilation time the compiler will take the initialized values and put them directly in the code section (`.text`), because local variables are stored on the stack, and assigned values have to be passed to these variables at runtime before being used later in the code.

###### Shellcode execution algorithm (C-like pseudo-code)

```c
// 1. allocate memory buffer in local process as Read/Write region to store shellcode 
exec_mem = VirtualAlloc(..., payload_length,..., PAGE_READWRITE)

// 2. copy shellcode into allocated memory buffer
RtlMoveMemory(exec_mem, payload, payload_length)

// 3. make the allocated buffer to be executable
VirtualProtect(exec_mem, payload_length, PAGE_EXECUTE_READ,...)

// 4. execute shellcode in local process by creating a new thread
CreateThread(..., exec_mem, ...)
```


###### Intel CPU Instructions

`NOP`

In x86 and x64 Intel CPU architectures, the **_NOP (No Operation)_** instruction is used to perform no operation or simply to introduce a delay in the program execution. It does not affect any of the CPU's flags or modify any registers.

The `NOP` instruction is represented by the opcode `0x90`.

---

`INT3`

**_INT3_** instruction is a **_software interrupt instruction_** that generates a breakpoint exception. It is used as a debugging aid and is often inserted into code intentionally to allow developers to pause the execution of a program at a specific location and inspect its state using a debugger.

The opcode for the `INT3` instruction is `0xCC`.

---

`RET`

**_RET (Return)_** instruction is used to return control from a subroutine to the calling function. It pops the return address from the top of the stack and transfers program execution to that address, effectively returning control to the caller.

The opcode for the `RET` instruction is `0xC3`.

---
#### Key Windows API functions

[**_VirtualAlloc()_**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function is used for reserving and committing memory in the virtual address space of a process. It allows a program to dynamically allocate memory during runtime, providing more flexibility and control over memory management. This function can be found in the _kernel32.dll_ library.

`VirtualAlloc()` function has the following prototype:

```c
LPVOID VirtualAlloc(
  LPVOID lpAddress,        // starting address of the region to allocate. If NULL, the system determines where to allocate the region
  SIZE_T dwSize,           // size of the region to allocate (in bytes)
  DWORD  flAllocationType, // type of memory allocation. Typically: MEM_COMMIT, MEM_RESERVE
  DWORD  flProtect         // memory protection for the region of pages to be allocated, ex. PAGE_READWRITE, PAGE_EXECUTE_READWRITE, etc.
);
```

**Return value**
If the function succeeds, the return value is the base address of the allocated region of pages. Otherwise, the return value is `NULL`.

---

[**_RtlMoveMemory()_**](https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory) function is used for memory block copy operations and is similar to the standard `memcpy` function. This function can be found in the _ntdll.dll_ library.

`RtlMoveMemory()` function has the following prototype:

```c
void RtlMoveMemory(
  void *Destination,    // pointer to the destination memory block to copy the bytes to
  const void *Source,   // pointer to the source memory block to copy the bytes from
  size_t Length         // number of bytes to copy from the source to the destination
);
```

**Return value**
None.

>In C, when you use the name of an array in an expression (except for `sizeof` and `&`), it **decays** to a pointer to its first element. So `payload` is equivalent to `&payload[0]` — a pointer of type `unsigned char *` that points to the first byte `0x90`.
>
>So passing `payload` to `RtlMoveMemory` gives the function the **address** of the data it should copy. That’s exactly what the function needs.

---

[**_VirtualProtect()_**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) function is used to change the protection attributes of a region of virtual memory in the address space of a process. This allows you to control the access rights and permissions for a particular memory region, such as making it readable, writable, executable, or a combination of these attributes. This function can be found in the _kernel32.dll_ library.

`VirtualProtect()` function has the following prototype:

```c
BOOL VirtualProtect(
  LPVOID lpAddress,      // address of the starting page of the region of pages whose access protection attributes are to be changed
  SIZE_T dwSize,         // size of the region whose access protection attributes are to be changed (in bytes)
  DWORD  flNewProtect,   // memory protection option, ex. PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE, PAGE_READWRITE, etc.
  PDWORD lpflOldProtect  // pointer to a variable that receives the previous access protection value. If NULL, the function fails
);
```

>  More on `PDWORD lpflOldProtect`; this is used to store previous page protection bits so the program can (if desired) restore them later. 
> 
> The function expects a pointer (`PDWORD`) for that parameter; using `&oldprotect` passes the address of your `DWORD` variable so the kernel can write the old protection value there.

> Don’t reuse the same variable for the restore call unless you handle it carefully

**Return value**
If the function succeeds, the return value is nonzero. Otherwise, the return value is zero.

---

[**_CreateThread()_**](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function is used to create a new thread within a process. In Windows, a **thread** is the smallest unit of execution within a process, and multiple threads can run concurrently, sharing the same resources of the process. This function can be found in the _kernel32.dll_ library.

`CreateThread()` function has the following prototype:

```c
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,  // determines whether the returned handle can be inherited by child processes. If NULL, no inheritance
  SIZE_T                  dwStackSize,         // initial size of the stack (in bytes)
  LPTHREAD_START_ROUTINE  lpStartAddress,      // pointer to the application-defined function to be executed by the thread
  LPVOID                  lpParameter,         // pointer to a variable to be passed to the thread
  DWORD                   dwCreationFlags,     // flags that control the creation of the thread, ex. CREATE_SUSPENDED, 0 (thread runs immediately after creation)
  LPDWORD                 lpThreadId           // pointer to a variable that receives the thread identifier
);
```

**Return Value**
If the function succeeds, the return value is a handle to the new thread. Otherwise, the return value is `NULL`

---

`WaitForSingleObject` waits for a specific kernel object (like a thread, process, or event) to finish or signal.

```c
DWORD WaitForSingleObject(
  HANDLE hHandle, //handle of the object to wait for (here: th, the thread handle)
  DWORD  dwMilliseconds // how long to wait before giving up
);
```

In the Windows API, `INFINITE` is defined as `0xFFFFFFFF`, which is **−1** in signed decimal.

So `WaitForSingleObject(th, -1)` means:

> “Wait forever until the thread finishes.”

That’s how the main program waits for your payload (the new thread) to complete before exiting.

---

#### What “unsigned” means

Every integer type in C (like `char`, `short`, `int`, `long`, etc.) can be **signed** or **unsigned**.  
That word controls whether the **most significant bit (MSB)** — the top bit — is used to represent **a sign (positive/negative)** or just treated as part of the number’s magnitude.

|Type|Range (typical 32-bit system)|Example|
|---|---|---|
|`int` (signed)|−2,147,483,648 → +2,147,483,647|can hold negatives|
|`unsigned int`|0 → 4,294,967,295|only nonnegative values|
|`char` (signed by default on some compilers)|−128 → +127|can hold negative bytes|
|`unsigned char`|0 → 255|always 0–255|

#### Why `unsigned` is used in your code

```c
unsigned char payload[] = {
    0x90, 0x90, 0xcc, 0xc3
};
unsigned int payload_len = 4;

```

- The **payload** is raw **machine code bytes**, not numbers meant for arithmetic.
- Each byte value ranges from 0x00 to 0xFF (0–255).
- Using `unsigned char` ensures the bytes are **not treated as negative values** (which could happen if `char` were signed and you used something like `0xCC`, which is 204 decimal → signed `char` would read as −52).
- The `unsigned int` for the length is just a natural fit: the length can’t be negative.

So “unsigned” means:

- store the bit pattern as-is (no sign interpretation),
- arithmetic wraps around instead of going negative,
- comparisons and casts behave predictably for binary data.

Difference example
```c
signed char a = 0xFF;       // -1 on most systems
unsigned char b = 0xFF;     // 255

printf("%d %u\n", a, b);
// Output: -1 255

```

---

#### More on `LPTHREAD_START_ROUTINE`

`LPTHREAD_START_ROUTINE` is a Windows typedef for a **pointer to a function** that matches the thread-entry signature. It’s defined roughly like this:

```c
typedef DWORD (WINAPI *LPTHREAD_START_ROUTINE)(LPVOID lpParameter);
```

That reads: _LPTHREAD_START_ROUTINE is a pointer to a function that takes one `LPVOID` argument and returns a `DWORD`._

- The `WINAPI` specifies the calling convention (more on that below).
    
So `CreateThread` expects its 3rd argument to be a pointer to a function with that signature — i.e. a pointer to code that will be invoked like:

```c
DWORD ThreadProc(LPVOID param) { /* ... */ return 0; }
```

---

#### More on LPVOID

`LPVOID` is a Windows typedef for `void *`:

```c
typedef void *LPVOID;
```

