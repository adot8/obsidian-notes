
**_Function call obfuscation_** in the context of Windows API refers to a technique used by software developers or malware authors to hide or obscure the actual calls to Windows API functions in their code. The goal is to make it harder for reverse engineers and analysts to understand the behavior of the program or to detect specific malicious activities.

Typically when the compiler+linker generate the binary, a list of needed DLLs and functions are being added to Import Table of the final PE file. Based on this information one can try to figure out, what kind of activities the program will perform when loaded into the system's memory.

To circumvent this analysis, malware authors switch to calling Win API functions dynamically, ie. resolving needed functions addresses on-the-fly by using `GetModuleHandle()` and `GetProcAddress()` functions.

Review Win32APIs in import table

```powershell
dumpbin /imports .\implant.exe
```

---

Code snippet

```c
```


---

##### Key Windows API functions

[**_GetModuleHandleA()_**](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea) retrieves a module handle for the specified module. The module must have been loaded by the calling process. This function can be found in the _kernel32.dll_ library.

`GetModuleHandleA()` function has the following prototype:
```c
HMODULE GetModuleHandleA(
  LPCSTR lpModuleName    // name of the loaded module (either a .dll or .exe file). If NULL, returns a handle to the file used to create the calling process (.exe file).
);
```

**Return value**
If the function succeeds, the return value is a handle to the specified module. Otherwise, the return value is `NULL`.

---

[**_GetProcAddress()_**](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) retrieves the address of an exported function or variable from the specified dynamic-link library (DLL). This function can be found in the _kernel32.dll_ library.

`GetProcAddress` function has the following prototype:

```c
FARPROC GetProcAddress(
    HMODULE hModule,    // handle to the DLL module that contains the function or variable
    LPCSTR  lpProcName  // function or variable name, or the function's ordinal value
);
```

**Return value**
If the function succeeds, the return value is the address of the exported function or variable. Otherwise, the return value is `NULL`.

---
##### Example with VirtualProtect()

First look up `msdn FunctionName()` and copy the prototype and dll it lives in

 Define pointer to `VirtualProtect()` as a global variable; Keyword `WINAPI` needs to be used
```c
BOOL (WINAPI *pVirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
);
```

Get a handle module (dll) and address of the function
```c
pVirtualProtect = GetProcAddress(GetModuleHandleA("kernel32.dll"), "pVirtualProtect");
```

Use normally
```c
update_mem = pVirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
```

> Now this will run **BUT** with static analysis the string `VirtualProtect` can still be seen in the `GetProcAddress()` function
> 
> `strings -n 8 implant.exe | findstr /i "virtual"`
> 
> We can obfuscate this using XOR encryption and making the key a non sus string that has already been seen in the binary