
https://www.youtube.com/watch?v=-ULuDh-vh_I

All these words are Windows-specific data types, defined in the Windows headers (<Windows.h>)
They’re basically **aliases** (typedefs) for normal C integer types of fixed width.

```c
typedef unsigned short WORD;     // 16 bits
typedef unsigned long  DWORD;    // 32 bits
typedef unsigned long long QWORD; // 64 bits (not always defined everywhere)
```

|Windows Type|Bits|C Equivalent (on Win32/Win64)|
|---|---|---|
|BYTE|8|unsigned char|
|WORD|16|unsigned short|
|DWORD|32|unsigned long (uint32_t)|
|QWORD|64|unsigned long long (uint64_t)|

The point is **type consistency between your code and the Windows API**.

When you call Windows functions, they expect parameters of those specific types:

```c
BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
);
```

- `flNewProtect` is a `DWORD` (32-bit flags).
- `lpflOldProtect` is a `PDWORD` (pointer to a DWORD).

If you passed a plain int or long, it might work on one compiler but fail or warn on another.
Using `DWORD` ensures the size and semantics are exactly what the API expects.

Example:

```c
DWORD access = PAGE_EXECUTE_READWRITE;
BOOL success = VirtualProtect(exec_mem, payload_len, access, &oldProtect);
```

- `access` is a 32-bit value holding flags.
- `oldProtect` is a `DWORD` that receives the old protection mode.    
- The API expects those types exactly — because internally the kernel expects a 32-bit field.

If you used a `long long` (64 bits), it could pass extra bytes, misalign the stack, or break ABI compatibility.

> So pretty much, you use `WORDs`, `DWORDs`, and `QWORDs` in Windows programming to make sure your variables are exactly the size and type that the Windows API expects — guaranteeing consistent behavior across all versions of Windows and compilers.