
#### Defining Structures

![[Pasted image 20251023101813.png]]

> It’s important to note that the member variables should only be declared and not initialized. Attempting to give the member variable values will lead to an error.
> 
> Don't forget the `;` at the end `}`

```c
#include <stdio.h>

int main(void) {
  // Write your code below
  struct Person {
    char firstName[25];
    int age;
  };
}
```

#### Initializing Structures

```c
struct Bottle {
  char* name;
  int maxCapacity;
  int currentCapacity;
};

struct Bottle bottle1 = {"superBottle", 24, 0};

```

For the example above:

- The `struct` keyword - once again
- The user-defined struct type, `Bottle`
- The name of the structure variable, `bottle1`
- The member variable value assignments within a set of curly braces, `{}`

If you wish to be more specific with your initialization and not worry about putting elements in the right order you can do it using an unordered notation:

```c
struct Bottle bottle1 = {
  .maxCapacity = 24,
  .name = "superBottle",
  .currentCapacity = 0
};
```

```C
#include <stdio.h>

int main(void) {
  struct Person {
    char firstName[25];
    // Write your code below
    char lastName[40];
    int age;
  };
  
  // Write your code below
  struct Person person1 = {"Ada", "Lovelace", 28};
  struct Person person2 = {"Marie", "Curie", 44};


  /* struct Person person2 = {
    .firstName = "Marie",
    .lastName = "Curie",
    .age = 44
  }; */
}
```


#### Why Use Structures

Using a struct to encapsulate all the members that represent a `Bottle` we can:

1. Reduce complexity by representing a set of data with one variable
2. Package different, but logically similar, data together
3. Better represent real-world “things” into data types

Being able to represent data using structures is extremely beneficial as you continue working on more complex real-world problems.

```C
struct Bottle {
  char* name;
  int maxCapacity;
  int currentCapacity;
};

struct Bottle bottle1 = {"Medium Bottle", 24, 0};
struct Bottle bottle2 = {"Large Bottle", 48, 20};

```

```c
#include <stdio.h>

// Write your code below
struct Table {
  int length;
  int width;
  int height;
  char color[20];

};

int main(void) {
 /* int table1Length = 24;
  int table1Width = 24;
  int table1Height = 20;
  char table1Color[20] = "Dark Brown";

  int table2Length = 42;
  int table2Width = 18;
  int table2Height = 32;
  char table2Color[20] = "Matte Black"; 
 */
  // Write your code below
  struct Table table1 = {
    .length = 24,
    .width = 24,
    .height = 20,
    .color = "Dark Brown"
  };

  struct Table table2 = {
    .length = 42,
    .width = 18,
    .height = 32,
    .color = "Matte Black"
  };

}
```


#### Structure Dot Notation

Dot notation is a C operator that allows you to access and modify a member variable of a structure.

```c
struct Bottle {
  char* name;
  int maxCapacity;
  int currentCapacity;
};

struct Bottle myBottle = {"Medium Bottle", 24, 0};

// Fill some of myBottle
myBottle.currentCapacity = 10;
printf("The bottle is now filled to %d", myBottle.currentCapacity);

```

In the example above:

- A bottle structure is defined and initialized with the variable `myBottle`
- The member variable `currentCapacity` is accessed and set to `10` with `myBottle.currentCapacity = 10`
- The same variable is accessed again using the dot operator and output with `printf()`

You can also use the dot operator to initialize a structure if you’d like to declare it first without initializing it right away like:

```c
struct Bottle myBottle;
myBottle.name = "Medium Bottle";
myBottle.maxCapacity = 24;
myBottle.currentCapacity = 0;
```

```c
#include <stdio.h>

struct Person {
  char name[40];
  int age;
};

int main(void) {
  struct Person person1 = {"Martin"};
  struct Person person2 = {"Michelle"};
  // Write your code below
  person1.age = 57;
  person2.age = 27;

  printf("Hello my name is %s and I am %d years old.\n", person1.name, person1.age);
  printf("Hello my name is %s and I am %d years old.\n", person2.name, person2.age);
}
```


#### Structure Pointers

Structures can use a lot of memory. Imagine a structure with multiple strings each able to hold hundreds of characters.  

One way to manage memory while working on data types of this size is the use `pointers`. As a reminder, a pointer is a variable that holds the memory address to another variable. 

For structures, this is accomplished by first defining the structure variable, then defining a pointer and assigning it the address to the structure variable. 

```c
struct Bottle myBottle = {"Medium Bottle", 24, 0};
struct Bottle* bottlePointer = &myBottle;
```

In the above example, `bottlePointer` holds the memory address pointing to `myBottle`.

To access member variables with `bottlePointer` and the dot operator we can use the following syntax:

```c
(*bottlePointer).name;
(*bottlePointer).maxCapacity;
(*bottlePointer).currentCapacity;
```

When using pointers we need to dereference, `*`, the address to access the variable it points to. When using the dot operator with structure pointers, we also need to wrap the dereference in parenthesis, `()`. If we simply dereference like `*aPointer.name`, it will result in an error.

Arrow notation can also be used with pointers to structures, as it implicitly does the dereferencing for you.

```c
aPointer->name;
aPointer->maxCapacity;
aPointer->currentCapacity;
```

```c
#include <stdio.h>

struct Person {
  char name[40];
  int age;
};

int main(void) {
  struct Person person1 = {"Martin", 57};
  struct Person person2 = {"Michelle", 27};
  // Write your code below
  struct Person *person1Pointer = &person1;
  struct Person *person2Pointer = &person2;

  //Dereference and adjust
  (*person1Pointer).age++;
  person2Pointer->age += 10;

  printf("Hello my name is %s and I am %d years old.\n", person1.name, person1.age);
  printf("Hello my name is %s and I am %d years old.\n", person2.name, person2.age);
}
```