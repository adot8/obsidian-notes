
> A pointer is a variable that stores a memory address, which typically represents the location of another variable.

> In C, a byte of memory can be accessed using a _pointer_. A pointer containing the address of a variable is said to “point” to that variable.

A pointer to a variable is the address of the first of these bytes. A pointer can be created for every type of variable: be it primitive (for example `int`, `char`, or `double`), a custom data type created using a `struct`, or even another pointer. The syntax of a pointer is the following:


	`dataType* nameOfPointer;`

or

	`dataType *nameOfPointer;`

For example, to declare a pointer variable (called ptr) that points to an int, you would write:
```c
int* ptr; // Pointer to an int
int *ptr; // Same as above but different style.
```

In this case, ptr stores the address of the first byte of a block of memory containing an int. To print this address to the screen, `printf()` is used like so:

```c
int x; // Create an int variable
int* ptr = &x; // Pointer to that int (we'll dive into what "&" means in the coming exercises)
printf("%p", ptr); // %p needed to instruct printf() that ptr is of type pointer

```

This will output a hexadecimal integer that represents the address in memory that is storing a variable of type int. This number will be different every time the program is executed. 

If we had another pointer named ptr2 that doesn’t point to a declared variable, printing it will result in (nil) rather than a hexadecimal address:
```c
int* ptr2;
printf("%p", ptr2); // Prints: (nil)
```

```c
#include<stdio.h>

int main() {
  // Checkpoint 1 code goes here.
  double dblVar;
  // Checkpoint 2 code goes here.
  double *dblPtr = &dblVar;
  // Checkpoint 3 code goes here.
  printf("%p", dblPtr);
}
```


The Reference Operator

Since pointers are used to store the memory address of a variable, we need to obtain this address first. This is done by using the reference operator (&). The syntax for this is:

    &variableName;

```c
int x = 727; // Declare variable x
int* ptr = &x; // Declare a pointer to an int variable and assign to it the address of variable x
printf("%p\n", &x); // Print the address of x
printf("%p\n", ptr); // Print the address pointed to by ptr 
```

The code above declares an integer variable `x` and an `int` pointer variable `ptr`. The pointer is then assigned the memory of the variable `x`. The last two `printf()` statements print this address; both lines will output the same hexadecimal number as they both refer to the same address in memory.

The address a pointer contains is not constant. A pointer may be reassigned to a new address so long as type consistency is maintained (e.g., `int` pointer points to a variable of type `int`). Consider this example:

```c
int* ptr; // Declare pointer to an integer type

int x = 3; // Declare variable x
ptr = &x; // Assigns memory address of variable x to the pointer
printf("%p\n", ptr); // Prints address of variable x 

int y = 14; // Declare variable y
ptr = &y; // Reassigns the pointer to the memory address of variable y
printf("%p\n", ptr); // Prints address of variable y
```

```c
#include<stdio.h>

int main() {
  
  double g = 9.81;
  double pi = 3.14;
  
  // Checkpoint 1 code goes here.
  double *dblPtr = &g;
  // Checkpoint 2 code goes here.
  printf("%p\n", dblPtr);
  // Checkpoint 3 code goes here.
  dblPtr = &pi;
  printf("%p", dblPtr);
 
}
```


---
### Theory

For a program to execute, it must use some of the computer’s resources such as CPU, RAM, IO, or other hardware. Deciding how and at what capacity to use these resources is the job of the underlying operating system. One of the most important of these resources is memory, more specifically: the temporary memory used for program execution which is called random access memory (RAM). When a program executes, the operating system reserves a section of the computer’s physical RAM to be used exclusively by the program. The fundamental unit of this memory is a byte. As you learned previously, all variables are simply a collection of some number of bytes: an `int` is four bytes, a `double` is eight bytes, and so on. The allocated section of RAM is simply a block of however many bytes the program needs (if available, of course).

As you can see, in this block of memory to the right, every byte has an associated address numbered using the hexadecimal numbering system. For example, a byte of memory could be located at address `0x200` and the immediate byte next to it is located at address `0x201`. 

Every programming language has a different policy regarding the direct access and manipulation of a byte in memory; some allow it, some do not. C is one of the languages that allow such operations through the use of a _pointer_, and we will see how in this lesson.

At first glance, pointers may appear to be an overcomplicated way to work with variables, and for such simple examples meant to illustrate basic principles, this is true. However, the real value of pointers becomes apparent in more complex applications, such as working with data
structures or embedded systems (think robots and microchips). Examples of these are well beyond the scope of this introductory tutorial. 

![[Pasted image 20251016113152.png]]
