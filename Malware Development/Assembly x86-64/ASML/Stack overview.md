
### The Stack 1

- A stack in Last-In-First-Out (LIFO) data structure where data is "pushed" on to the top of the stack and "popped" off the top

> This can be thought of as a stack of plates where you can only take data (plates) off the top but not from the middle.

![[Pasted image 20250908214041.png]]

- The stack is a conceptual area of main memory (RAM) which is designated by the OS when a program is started 

> Essentially says hey this is the section of memory i got ready for fortnite.exe

- Different OSes start at different addresses by their own convention, or if they're using address space layout randomization (ASLR) this can be randomised

---
### The Stack 2

By convention **the `stack` grows toward lower memory addresses (and the `heap` higher)**. Adding something to the stack means the top of the stack is now at the lower memory address

> If you use too much `stack` and or too much `heap` they'll collide and cause the program to exit 

![[Pasted image 20250908214717.png]]

# THE STACK GROWS DOWN (Lower Addresses)

---
### The Stack 3

- RSP (Really-long stack pointer) points to the top of the stack - **_The lowest address which is being used_** 
	- While data will exist at addresses beyond the top of the stack, it is considered _undefined_

---

### The Stack 4

- What can you find on the stack?
	- "Return addresses" so a called function can return back to the function that called it
	-  Local variables
	- _Sometimes_ used to pass arguments between functions
	-  Save space for registers so functions can share registers without smashing the value for each other (so function1 won't overwrite the values from function2)
	-  Save space for registers when the compiler has to juggle too many in a function (a function gets too complication and 16 registers aren't enough for all the possible values)
	- Dynamically allocated memory via alloca() - (explicitly allocate space on the stack instead of the heap)

---

### Simple Stack Diagram

![[Pasted image 20250908220207.png]]

1. `main` will run first so it creates a conceptual area called a`frame` for itself at the bottom of the stack. It's frame is a place to keep it's information (It may have stuff, it may not)
2. `main` is calling  `foo` which allows `foo` to make a frame for itself on top of `main` to save it's information
3. `foo` is calling to `bar` which allows `bar` to add a frame on top of `foo` to save it's information
4. As functions call other functions the stack moves towards lower addresses where new frames are created **AND** as functions return from other functions the stack has data coming back off it and the frames disappear (plates being taken off the top) 