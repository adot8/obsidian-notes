
### CallASubroutine1.c
![[Pasted image 20250915221944.png]]

### CALL - Call Procedure

- CALL's job is to transfer control to a different function; in a way that control can later be resumed where it left off
- First it _pushes_ the address of the next instruction onto the stack
	- For use by RET for when the procedure is done
- Then it changes RIP (really long instruction player) to the address given in the instruction

- Destination address for the target function can be specified in multiple ways
	- Absolute address
	- Relative address (relative to the end of the instruction, or some other register)

### RET - Return from Procedure

- Two forms:
1. Pop the top of the stack into RIP **(remember pop implicitly increments stack pointer, RSP by 8)**
	-  In this form, the instruction is just written as `ret`
> Whatever on the stack, stick it into RIP and RSP + 8

2. Pop the top off the stack into RIP and also add a constant number of bytes to RSP
	- In this form the instruction is written as `ret 0x08`, or `ret 0x20`, etc
> Whatever on the stack, stick it into RIP and RSP + 8 **AND** an extra 8 bytes or 20 bytes, etc.


### How to read two-operand instructions
#### Intel vs. AT&T Syntax

- Intel: Destination <- Source(s)
	- Windows. Think algebra or C: `y = 2x +1;`
	- Should be read right to left
	- `mov    rbp, rsp` ; (move rsp into rbp)
	- `add    rsp, 0x14` ; (rsp = rsp + 0x14)

- AT&T: Source(s) -> Destination
	- \*nix/GNU. Think pre-school: 1 + 1 = 2
	- `mov    %rsp, %rbp` ; (move rsp into rbp)
	- `add    $0x14, %rsp`
	- Registers get a % prefix and immediated get a $

### MOV - Move

- Can move:
	- register to register
	- memory to register, register to memory
	- immediate to register, immediate to memory
- **CAN NEVER MOVE MEMORY TO MEMORY**
- Memory addresses are given in "r/mX" form

> Intel can't support 64 bit immediate values when moving (`mov`) them into memory, only 32; it does support 64 bit immediate values for moving into registers though
> See below:

![[Pasted image 20250915224448.png]]


###  ADD and SUB

- Adds or Subtracts, just as expected
- Destination operand can be `r/mX` or a register
- Source operand can be `r/mX` or a register or an immediate
- No source **and** destination as `r/mXs`, because that could allow for memory to memory transfer which isn't allowed on x86 

> Memory to memory just don't exist period

Examples:
- `add    rsp, 8`  ->  (rsp = rsp +8)
- `sub    rax, [rbx*2]`   ->  (rax = rax - memorypointedtoby(rbx\*2)) 

> Intel form; destination always on the left; read right to left