
### As seen in Hello.c (macOS and Linux)

Just like in the [Stack Overview](obsidian://open?vault=Offensive%20Security&file=root%2FMalware%20Development%2FAssembly%20x86-64%2FASML%2FStack%20overview) data gets pushed and popped which is what they do

![[Pasted image 20250908220923.png]]

![[Pasted image 20250908221040.png]]

> GCC/Clang HelloWorlds have balanced Push/Pop instructions but Windows VS doesn't (still the same)

![[Pasted image 20250908221203.png]]

---

# PUSH

### Push quadword onto the stack

- The push instruction automatically decrements the stack pointer, `RSP`, by 8
> This means that the stack grows 8 addresses (going to the lower address ofc)
- In 64-bit execution mode, operand (PUSH) can also be the following:
	- The value in a 64-bit register
	- A 64-bit value from memory, as given in "r/mX" from talked about next

### "r/mX" Addressing Forms 

- Bro made up "r/mX" to refer to anywhere you see "r/m8", "r/m16", "r/m32" or "r/m64" in the intel manual

![[Pasted image 20250908221913.png]]

> An "r/mX" is a way to specify either a register or memory value in 8,16,32 or 64 bits long

- In Intel syntax, most of the time square brackets [] means to treat the value within as a memory address, and fetch the value at that address and pull it out (like dereferencing a pointer)

- An "r/mX"  can take 4 forms
	1. Register -> `rbx`
	2. Memory, base-only -> `[rbx]`
		1. Take the value of rbx, treat it as a memory address, deference it, pull the value out of that and boom thats the value used instead (makes no sense lol) **DONT USE RBX USE THE VALUE POINTED TO bY RBX**
	3. Memory, base+index\*scale -> `[rbx+rcx*X]`
		1. Take register, add it to another register and times it by X
		2.  X can be 1,2,4 or 8 (nothing else)
	4. Memory, base+index\*scale+displacement -> `[rbx+rcx*X+Y]`
		1. 
		2. For Y of 1 byte (0-255  / 0-2^8) or 4 bytes (0-4 billion  /  0-2^32)

- ` base + index \*scale + displacement ` has a natural applicability to multi-dimensional array indexing, arrays of structs, etc

- For future instructions
	- Support access to memory = memory is encoded in "r/mX" form
	-  "r/mX" can be something as simple as a register or as complicated as a memory address calculation in that form

### PUSH "r/mX" Example 

1. Push register onto the stack
2. Take register, grab to memory, grab the value out of memory **THEN** push it onto the stack 
	1. Same shit for the others, just more mathematics after lol

![[Pasted image 20250908223621.png]]

> Nothing special about the particular registers; anything could have been used

---
# Note about the \` address convention

- When writing 64 bit numbers, it can be easy to lose track of whether you have the right number of digits
- WinDbg (which we don’t use in this class, but do in future architecture classes) allows you to write 64 bit numbers with a ` between the two 32 bit halves.
- I think this is helpful to see when a number is > 32 bit or not (because there will be some non-zero value on the left side of the `)
- So in this class I’ll often write 64 bit numbers like 0x12345678`12345678.
- But keep in mind that the only tool which probably supports you entering them like that is WinDbg

---

# push RAX example

>  The push instruction automatically decrements the stack pointer, `RSP`, by 8
> This means that the stack grows 8 addresses (going to the lower address ofc)


| Before                                                                       | After                                                                                                                             |
| ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| RAX is holding the value 3                                                   | RAX is pushed to the top of the stack (lower address)                                                                             |
| RSP is pointing at the top of the stack which is 14FE08 (location in memory) | RSP value changed to be decremented by 8 so now 14FE00 (location in memory)                                                       |
|                                                                              | RSP is still pointing to the top of the stack, which is the last bit of data actually used on the stack (the 3 i.e. value of RAX) |


![[Pasted image 20250908224525.png]]

---

# POP

### Pop a value from the stack

- In 64-bit execution mode, operand can be:
	1. Popped into a 64-bit register
	2. Popped into a 64-bit memory address, as given in "r/mX" form

### pop RAX Example

| Before                                                                       | After                                                                                                                               |
| ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| RAX is holding the value 7                                                   | 3 (14FE00) is popped off of the top of the stack and overwritten into RAX (previously 7)                                            |
| RSP is pointing at the top of the stack which is 14FE00 (location in memory) | RSP value is changed 14FE08 since it's at the top of the stack                                                                      |
| 14FE00 holds the value of 3                                                  | The frame/location 3 was previously in is "undefined" but really still there; compilers should never access memory beyond the stack |

![[Pasted image 20250908225841.png]]